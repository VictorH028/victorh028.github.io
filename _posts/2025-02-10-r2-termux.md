
Mucho gusto me pregunto soy usuario activo de la comunidad de ivam3 cindarela. Soy cubanl y curso el primer a√±o de ingenier√≠a y opero bajo el alias de DemonHunter. 

> [!NOTE]
> No te quedes con la duda de nada si no lo explico o no lo entiendes a buscalo en Internet 

__Sin m√°s pre√°mbulo para que estamos ac√°.__

En ocasiones no cumplimos nuestras metas por que no te nemos los recuerdos necesarios o esos creemos quien no tiene un dispositivo Android en su poder hoy en d√≠a. Usando termux ser√° lo que usted desee. 


Los temas sentrales que estar√© tocando ser√°n de an√°lisis a binarios y ingenier√≠a inversa usando termux el objetivo no ser√° optener la bandera sino tocar en detalles los aspectos a tender en cuenta para llegar a la meta . 

Comenzando con nuestro primer CTF en la plataforma de [Tryhackme](https://tryhackme.com/room/reverse files) ...



1. Procedemos a descargar el archivo de el primer desaf√≠o 


Estaremos asiendo un _an√°lisis estatico_ del mismo 

**En que consiste el an√°lisis est√°tico**

- An√°lisis el archivo sin ejecutarlo üòé

Aunque quisi√©ramos no podriamos ejecutarlo entre comillas. Pero bueno no es el caso ahora...

Empezamos con lo m√°s b√°sico que es saber a que nos estamos enfrentando usando. 

```sh
file crackme1
```

```sh
crackme1: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=672f525a7ad3c33f190c060c09b11e9ffd007f34, not stripped
```

Estructurado la salida optenida vamos a ver lo que tenemos un archivo `ELF 64 bist executable` compilado para  `x86-64 ` y el `LSB` lo que significa que los n√∫meros se ordenan con byte menos significativo en memera. 

Estaremos utilizando la herramienta de [radare2](url)  qu√© se puede instalar desde el administrador de paquetes apt con `apt install radare2` 

Procedemos a abrir el binario en `r2` 

Banderas:
`-A` : Para que analise todo el c√≥digo referenciado 

El comando 'print' se abrevia como `p` y tiene varios submodos pero no te agobies si le a√±ades `? ` tendr√°s un men√∫ de ayuda.  

Procedemos a desmontar la funci√≥n principal
`pdf @ main` 

![r2-main](path) 

### Buscando instrucciones relacionada con la pila 

   - Las instrucciones que manipulan la pila suelen ser:
     - `push`: Guarda un valor en la pila.
     - `pop`: Extrae un valor de la pila.
     - `mov [rbp - X], Y`: Guarda un valor en una posici√≥n espec√≠fica de la pila.
     - `lea`: Carga una direcci√≥n de memoria en un registro (a menudo usado para direccionar la pila).

Sabiendo lo anterior vemos que varios valores se guardan el la  `pila`  estos valores se almacenan en posiciones relativas al registro `rbp` que ser√≠a `rbp - 0x70, rbp - 0x6c` ect...  

radare2 agrega comentarios en autom√°tico en el c√≥digo, esto nos ayuda e entender que valores se est√°n guardando pero parese ser la bandera. 


### ¬ø Qu√© son los registros? 

Los egistro de procesador es una ubicaci√≥n de acceso r√°pido disponible para el procesador de una computadora

Los registros de `64 bits` tienen nombres que comienzan con ‚Äúr‚Äù, por lo que, por ejemplo, la extensi√≥n de 64 bits de `eax` se llama `rax`. Los nuevos registros se denominan `r8` a `r15` ojo con los hibridos xD:

### Llamada a funciones 

Cuando se llama a una funci√≥n, el compilador utiliza un marco de pila (ubicado dentro de la pila de ejecuci√≥n del programa ) para almacenar toda la informaci√≥n temporal que la funci√≥n requiere para operar. Dependiendo de la convenci√≥n de llamada, la funci√≥n que llama colocar√° la informaci√≥n antes mencionada en registros espec√≠ficos o en la pila del programa o en ambos.

En Linux, se colocar√°n los argumentos en los registros `RDI`, `RSI`, `RDX`, `RCX`, `R8` y `R9` y cualquier cosa adicional se colocar√° en la pila.


Tenemos dos llamadas a  funci√≥n y una es  la funci√≥n `memset()` y `puts()` qu√© la podemos identificar por la instrucci√≥n de `call` qu√© es la encargada de llamar a un  funci√≥n.

Ya sabiendo lo anterior tenemos una funci√≥n llamada `memset() ` y los valores que toma por argumento . Buscando en Internet vemos que `C` cuenta con una funci√≥n del mismo nombre y no es creada por el usuario. (ojo)

El c√≥digo llama a `memset` para inicializar un bloque de memoria con el valor `0x41` (`'A'`):

   ```asm
   lea rax, [s]
   mov edx, 0x1b               ; 27 ; size_t n
   mov esi, 0x41               ; 'A' ; 65 ; int c
   mov rdi, rax                ; void *s
   call sym.imp.memset         ; void *memset(void *s, int c, size_t n)
   ```
   
Esto llena 27 bytes con el car√°cter `'A'`.

Despu√©s nos topamos con un bucle que  realiza una operaci√≥n de transformaci√≥n sobre los valores inicializados. 

### a)**Inicializaci√≥n del bucle**
   ```asm
   mov dword [var_4h], 0
   jmp 0x400669
   ```

   #### b) **Cuerpo del bucle**
   ```asm
   mov eax, dword [var_4h]
   cdqe
   movzx eax, byte [rbp + rax - 0x90]
   mov edx, eax
   mov eax, dword [var_4h]
   cdqe
   mov eax, dword [rbp + rax*4 - 0x70]
   add eax, edx
   mov edx, eax
   mov eax, dword [var_4h]
   cdqe
   mov byte [rbp + rax - 0x90], dl
   add dword [var_4h], 1
   ```

- El bucle itera sobre un arreglo de bytes.
- Para cada iteraci√≥n, toma un valor del arreglo `[rbp + rax - 0x90]` y lo suma con un valor del arreglo `[rbp + rax*4 - 0x70]`.
- El resultado se almacena de nuevo en `[rbp + rax - 0x90]`.

   #### c) **Condici√≥n del bucle**
   ```asm
   cmp eax, 0x1a               ; 26
   jbe 0x40063d
   ```
   - El bucle se ejecuta mientras `eax` sea menor o igual a `0x1a` (26).

Despu√©s del bucle, el c√≥digo imprime el contenido de `[s]` usando `puts`:

   ```asm
   lea rax, [s]
   mov rdi, rax                ; const char *s
   call sym.imp.puts           ; int puts(const char *s)
   ```

---

El bucle realiza una operaci√≥n de transformaci√≥n sobre los valores inicializados. Podemos inferir que:
- El arreglo `[rbp - 0x90]` contiene 27 bytes inicializados con `'A'`.
- El arreglo `[rbp - 0x70]` contiene los valores constantes inicializados al principio.
- Para cada byte en `[rbp - 0x90]`, se suma el valor correspondiente de `[rbp - 0x70]` y se almacena el resultado.

Bueno ya sabemos lo que esta haciendo el programa esta generando una cadena transformada a partir de los valores guardados en la pila sabiendo esto vamos a tratar de recrear el programa bueno no lo dejo de tarea. Bueno ac√° el resumen. 

De lo que pasa dentro del bucle. 

Podemos realizar la operaci√≥n matem√°tica directa mente de la l√≠nea de comandos de radare2 usando la calculadora integrada usando el comando de `? (valores) ` permite hacer c√°lculos en diferentes bases 

`? 0x41 + 0x25`

Fue un placer.... 
